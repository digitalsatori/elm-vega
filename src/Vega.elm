module Vega
    exposing
        ( AggregateProperty(..)
        , Autosize(..)
        , AxisElement(..)
        , AxisProperty(..)
        , Bind(..)
        , CInterpolate(..)
        , ColorValue(..)
        , Comparator(..)
        , Cursor(..)
        , DataColumn
        , DataProperty(..)
        , DataReference(..)
        , DataRow
        , DataTable
        , DataType(..)
        , DataValue(..)
        , DataValues(..)
        , EncodingProperty(..)
        , EventHandler(..)
        , Expr(..)
        , Expression
        , Facet(..)
        , Field(..)
        , FieldValue(..)
        , Format(..)
        , FormulaUpdate(..)
        , HAlign(..)
        , InputProperty(..)
        , LegendEncoding(..)
        , LegendOrientation(..)
        , LegendProperty(..)
        , LegendType(..)
        , Mark(..)
        , MarkInterpolation(..)
        , MarkOrientation(..)
        , MarkProperty(..)
        , Operation(..)
        , Order(..)
        , OverlapStrategy(..)
        , PackProperty(..)
        , Padding(..)
        , PieProperty(..)
        , RangeDefault(..)
        , Scale(..)
        , ScaleDomain(..)
        , ScaleNice(..)
        , ScaleProperty(..)
        , ScaleRange(..)
        , SchemeProperty(..)
        , Side(..)
        , SignalBoolean(..)
        , SignalNumber(..)
        , SignalProperty(..)
        , SignalReference(..)
        , SignalString(..)
        , SortProperty(..)
        , Source(..)
        , Spec
        , StackOffset(..)
        , StackProperty(..)
        , StrokeCap(..)
        , StrokeJoin(..)
        , Symbol(..)
        , TextDirection(..)
        , TimeUnit(..)
        , TopMarkProperty(..)
        , Transform(..)
        , Trigger
        , TriggerProperty(..)
        , VAlign(..)
        , VProperty
        , Value(..)
        , autosize
        , axes
        , axis
        , combineSpecs
        , cursorLabel
        , data
        , dataColumn
        , dataFromColumns
        , dataFromRows
        , dataRow
        , dataSource
        , dirLabel
        , hAlignLabel
        , height
        , legend
        , legends
        , mark
        , markInterpolationLabel
        , markOrientationLabel
        , marks
        , on
        , padding
        , scale
        , scales
        , sigHeight
        , sigPadding
        , sigWidth
        , signal
        , signals
        , strokeCapLabel
        , strokeJoinLabel
        , symbolLabel
        , toVega
        , transform
        , trigger
        , vAlignLabel
        , width
        )

{-| This module will allow you to create a full Vega specification in Elm. A
specification is stored as a JSON object and contains sufficient declarative detail
to specify the graphical output. While this a 'pure' Elm library, to create the
graphical output you probably want to send a Vega specification generated by
`toVega` via a port to some JavaScript that invokes the Vega runtime.


# Creating A Vega Specification

Future development of this package will allow full Vega specifications to be provided.
Currently, only a very limited set of Vega options detailed below, is provided for
testing purposes only.

@docs toVega
@docs VProperty
@docs Spec
@docs combineSpecs


# Creating the Data Specification

Functions and types for declaring the input data to the visualization.

@docs dataSource
@docs dataFromColumns
@docs dataFromRows
@docs data
@docs dataColumn
@docs dataRow
@docs on
@docs trigger
@docs DataProperty
@docs DataColumn
@docs DataRow
@docs DataTable
@docs DataReference
@docs DataType
@docs Format
@docs SortProperty
@docs Source
@docs Trigger
@docs TriggerProperty


## Transformations

@docs Transform
@docs FormulaUpdate
@docs AggregateProperty
@docs PackProperty
@docs PieProperty
@docs StackProperty
@docs StackOffset

@docs transform
@docs Order
@docs Comparator


## Axes

@docs axes
@docs axis
@docs AxisProperty
@docs AxisElement
@docs Side
@docs OverlapStrategy


## Legends

@docs legends
@docs legend
@docs LegendProperty
@docs LegendType
@docs LegendOrientation
@docs LegendEncoding


## Marks

@docs marks
@docs mark
@docs Mark
@docs TopMarkProperty
@docs MarkProperty
@docs EncodingProperty
@docs MarkInterpolation
@docs markInterpolationLabel
@docs MarkOrientation
@docs markOrientationLabel
@docs Cursor
@docs cursorLabel
@docs HAlign
@docs hAlignLabel
@docs VAlign
@docs vAlignLabel
@docs Symbol
@docs symbolLabel
@docs StrokeCap
@docs strokeCapLabel
@docs StrokeJoin
@docs strokeJoinLabel
@docs TextDirection
@docs dirLabel


## Signals

@docs signals
@docs signal
@docs SignalBoolean
@docs SignalNumber
@docs SignalString
@docs SignalReference
@docs SignalProperty
@docs Bind
@docs InputProperty
@docs EventHandler
@docs sigWidth
@docs sigHeight
@docs sigPadding


## Scaling

The mapping of data values to their visual expression.

@docs scales
@docs scale
@docs RangeDefault
@docs ScaleProperty
@docs Scale
@docs ScaleDomain
@docs ScaleRange
@docs ScaleNice
@docs SchemeProperty
@docs CInterpolate


## Aggregation

@docs Operation


# Global Configuration

Configuration options that affect the entire visualization. These are in addition
to the data and transform options described above.

@docs autosize
@docs height
@docs padding
@docs width
@docs Autosize
@docs Padding


# General Data types

In addition to more general data types like integers and strings, the following types
can carry data used in specifications.

@docs DataValue
@docs DataValues
@docs TimeUnit
@docs ColorValue
@docs Expr
@docs Expression
@docs Field
@docs FieldValue
@docs Value
@docs Facet

-}

import Json.Encode as JE


-- TODO: Most types should have the option of representing their type from a signal
-- See StOffset as an example


{-| Properties of the aggregate transformation. For details see the
[Vega documentation](https://vega.github.io/vega/docs/transforms/aggregate/)
-}
type AggregateProperty
    = AgGroupBy (List Field)
    | AgFields (List Field)
    | AgOps (List Operation)
    | AgAs (List String)
    | AgCross Bool
    | AgDrop Bool


{-| Indicates the auto-sizing characteristics of the visualization such as amount
of padding, whether it should fill the parent container etc. For more details see the
[Vega documentation](https://vega.github.io/vega/docs/specification/#autosize-types)
-}
type Autosize
    = AContent
    | AFit
    | ANone
    | APad
    | APadding
    | AResize


{-| Encodable axis element. Used for customising some part of an axis. For details
see the [Vega documentation](https://vega.github.io/vega/docs/axes/#custom).
-}
type AxisElement
    = EAxis
    | ETicks
    | EGrid
    | ELabels
    | ETitle
    | EDomain


{-| Indicates the characteristics of a chart axis such as its orientation, labels
and ticks. For more details see the
[Vega documentation](https://vega.github.io/vega/docs/axes)
-}
type AxisProperty
    = AxScale String
    | AxSide Side
    | AxDomain Bool
    | AxEncode (List ( AxisElement, List EncodingProperty ))
    | AxFormat String
    | AxGrid Bool
    | AxGridScale String
    | AxLabels Bool
      -- TODO: Check that AxLabelBound and Flush set to True is equivalent to setting to 1
    | AxLabelBound (Maybe Float)
    | AxLabelFlush (Maybe Float)
    | AxLabelFlushOffset Float
    | AxLabelPadding Float
    | AxLabelOverlap OverlapStrategy
    | AxMinExtent Value
    | AxMaxExtent Value
    | AxOffset Value
    | AxPosition Value
    | AxTicks Bool
      -- TODO: Need to account for temporal units and intervals
    | AxTickCount Int
    | AxTickSize Float
    | AxTitle Value
    | AxTitlePadding Float
    | AxValues (List Value)
    | AxZIndex Int


{-| Describes a binding to some HTML input element such as a checkbox or radio button.
For details see the [Vega documentation](https://vega.github.io/vega/docs/signals/#bind).
-}
type Bind
    = IRange (List InputProperty)
    | ICheckbox (List InputProperty)
    | IRadio (List InputProperty)
    | ISelect (List InputProperty)
    | IText (List InputProperty)
    | INumber (List InputProperty)
    | IDate (List InputProperty)
    | ITime (List InputProperty)
    | IMonth (List InputProperty)
    | IWeek (List InputProperty)
    | IDateTimeLocal (List InputProperty)
    | ITel (List InputProperty)
    | IColor (List InputProperty)


{-| Indicates the type of color interpolation to apply, when mapping a data field
onto a color scale. For details see the
[Vega documentation](https://vega.github.io/vega/docs/scales/#quantitative).
-}
type CInterpolate
    = CubeHelix Float
    | CubeHelixLong Float
    | Hcl
    | HclLong
    | Hsl
    | HslLong
    | Lab
    | Rgb Float


{-| Defines a custom colour value. Can use a variety of colour spaces such as RGB,
HSL etc. For more details, see the
[Vega documentation](https://vega.github.io/vega/docs/types/#ColorValue)}
-}
type
    ColorValue
    -- TODO: Need to be able to express these values as the result of scale transforms (see https://vega.github.io/vega/docs/types/#ColorValue )
    = RGB Float Float Float
    | HSL Float Float Float
    | LAB Float Float Float
    | HCL Float Float Float


{-| Defines how sorting should be applied. For details see the
[Vega documentation](https://vega.github.io/vega/docs/types/#Compare)
-}
type Comparator
    = CoField (List Field)
    | CoOrder (List Order)


{-| Represents the type of cursor to display. For an explanation of each type,
see the [CSS documentation](https://developer.mozilla.org/en-US/docs/Web/CSS/cursor#Keyword%20values)
-}
type Cursor
    = CAuto
    | CDefault
    | CNone
    | CContextMenu
    | CHelp
    | CPointer
    | CProgress
    | CWait
    | CCell
    | CCrosshair
    | CText
    | CVerticalText
    | CAlias
    | CCopy
    | CMove
    | CNoDrop
    | CNotAllowed
    | CAllScroll
    | CColResize
    | CRowResize
    | CNResize
    | CEResize
    | CSResize
    | CWResize
    | CNEResize
    | CNWResize
    | CSEResize
    | CSWResize
    | CEWResize
    | CNSResize
    | CNESWResize
    | CNWSEResize
    | CZoomIn
    | CZoomOut
    | CGrab
    | CGrabbing


{-| Represents a single column of data. Used when generating inline data with
`dataColumn`.
-}
type alias DataColumn =
    List LabelledSpec


{-| Represents a single row of data. Used when generating inline data with
`dataRow`.
-}
type alias DataRow =
    Spec


{-| Represents a single table of data (collection of `dataColumn`s).
-}
type alias DataTable =
    List LabelledSpec


{-| Properties to customise data loading. For details, see the
[Vega documentation](https://vega.github.io/vega/docs/data/#properties)
-}
type DataProperty
    = DFormat Format
    | DSource String
    | DSources (List String)
    | DValue Value
    | DOn (List Trigger)
    | DUrl String


{-| Reference to one or more sources of data such as dataset, field name or collection
of fields. For details see the
[Vega documentation](https://vega.github.io/vega/docs/scales/#dataref)
-}
type DataReference
    = DDataset String
    | DField Value
    | DFields (List Value)
    | DReferences (List DataReference)
    | DSort (List SortProperty)


{-| Indicates the type of data to be parsed when reading input data. For `FoDate`
and `FoUtc`, the formatting specification can be specified using
[D3's formatting specifiers](https://github.com/d3/d3-time-format#locale_format) or
left as an empty string if default date formatting is to be applied. Care should
be taken when assuming default parsing of dates though as different browsers can
parse dates differently. Being explicit about the date format is usually safer.
-}
type DataType
    = FoNumber
    | FoBoolean
    | FoDate String
    | FoUtc String


{-| A single data value. This is used when a function can accept values of different
types (e.g. either a number or a string).
-}
type DataValue
    = Boolean Bool
    | Number Float
    | Str String
    | Empty
    | Null


{-| A list of data values. This is used when a function can accept lists of
different types (e.g. either a list of numbers or a list of strings).
TODO: Check DateTimes only accept strings.
-}
type DataValues
    = Booleans (List Bool)
    | DateTimes (List String)
    | Numbers (List Float)
    | Strings (List String)
    | DataValues (List DataValues)


{-| Indicates the charactersitcs of an encoding. For further
details see the [Vega documentation](https://vega.github.io/vega/docs/marks/#encode).
TODO: Need to expand this doc comment.
-}
type EncodingProperty
    = Enter (List MarkProperty)
    | Update (List MarkProperty)
    | Exit (List MarkProperty)
    | Hover (List MarkProperty)
    | Custom String (List MarkProperty)


{-| Specifies an event handler indicating which events to respond to and what to
update or encode as a result. For details see the
[Vega documentation](https://vega.github.io/vega/docs/signals/#handlers).
-}
type
    EventHandler
    -- TODO: Replace EEvents strings with full event stream types.
    = EEvents String
    | EUpdate String
    | EEncode String
    | EForce Bool


{-| A vega [Expr](https://vega.github.io/vega/docs/types/#Expr) that can be either
a field lookup or a full expression that is evaluated once per datum.
-}
type Expr
    = EField String
    | Expr Expression


{-| Represents an expression to enable custom calculations. This should be text
in the Vega expression language. For details see the
[Vega documentation](https://vega.github.io/vega/docs/expressions).
-}
type alias Expression =
    String


{-| Defines a facet directive. For details see the
[Vega documentation](https://vega.github.io/vega/docs/marks/#facet).
-}
type Facet
    = FaName String
    | FaData String
    | FaField String
      --TODO: | FaAggregate
    | FaGroupBy (List String)


{-| Represents a field name. For details see the
[Vega documentation](https://vega.github.io/vega/docs/types/#Field)
-}
type Field
    = FieldName String
    | FieldSignal String


{-| Represents a field value. Rather than a simple field name this can be used to
evaluate a signal, group or parent to indirectly reference a field. For details
see the [Vega documentation](https://vega.github.io/vega/docs/types/#FieldValue).
-}
type FieldValue
    = FName String
    | FSignal SignalReference
    | FDatum FieldValue
    | FGroup FieldValue
    | FParent FieldValue


{-| Specifies the type of format a data source uses. For details see the
[Vega documentation](https://vega.github.io/vega/docs/data/#format).
-}
type Format
    = JSON
    | CSV
    | TSV
    | DSV String
    | TopojsonFeature String
    | TopojsonMesh String
    | Parse (List ( String, DataType ))


{-| Defines whether a formula transformation is a one-off operation (`InitOnly`)
or is applied whenever an upstream dependency changes. For details see the
[Vega documentation](https://vega.github.io/vega/docs/transforms/formula/).
-}
type FormulaUpdate
    = InitOnly
    | AlwaysUpdate


{-| Indicates the horizontal alignment of some text such as on an axis or legend.
-}
type HAlign
    = AlignCenter
    | AlignLeft
    | AlignRight


{-| GUI Input properties. The type of relevant proerty will depend on the type of
input element selected. For example an `InRange` (slider) can have numeric min,
max and step values; InSelect (selector) has a list of selection label options.
For details see the [Vega documentation](https://vega.github.io/vega/docs/signals/#bind).
The `debounce` property, available for all input types allows a delay in input event
handling to be added in order to avoid unnecessary event broadcasting. The `Element`
property is an optional CSS selector indicating the parent element to which the
input element should be added. This allows the option of the input element to be
outside the visualization container.
-}
type InputProperty
    = Debounce Float
    | Element String
    | InOptions DataValues
    | InMin Float
    | InMax Float
    | InName String
    | InStep Float
    | InPlaceholder String
    | InAutocomplete Bool


{-| Indicates the position of a legend relative to the visualization it describes.
For details see the [Vega documentation](https://vega.github.io/vega/docs/legends/#orientation)
-}
type LegendOrientation
    = Left
    | TopLeft
    | Top
    | TopRight
    | Right
    | BottomRight
    | Bottom
    | BottomLeft
    | None


{-| Indicates the characteristics of alegend such as its orientation and scaling
to represent. For more details see the
[Vega documentation](https://vega.github.io/vega/docs/legends/)
-}
type LegendProperty
    = LeType LegendType
    | LOrient LegendOrientation
    | LFill String
    | LOpacity String
    | LShape String
    | LSize String
    | LStroke String
    | LStrokeDash String
    | LEncode (List LegendEncoding)
    | LEntryPadding Value
    | LFormat String
    | LOffset Value
    | LPadding Value
      -- TODO: Need to account for temporal units and intervals
    | LTickCount Int
    | LTitlePadding Value
    | LTitle String
    | LValues (List Value)
    | LZIndex Int


{-| Type of custom legend encoding. For more details see the
[Vega documentation](https://vega.github.io/vega/docs/legends/#custom)
-}
type LegendEncoding
    = EnLegend (List EncodingProperty)
    | EnTitle (List EncodingProperty)
    | EnLabels (List EncodingProperty)
    | EnSymbols (List EncodingProperty)
    | EnGradient (List EncodingProperty)


{-| Type of legend. `LSymbol` representing legends with discrete items and `LGradient`
for those representing continuous data.
-}
type LegendType
    = LSymbol
    | LGradient


{-| Type of visual mark used to represent data in the visualization. For further
details see the [Vega documentation](https://vega.github.io/vega/docs/marks/#types).
-}
type Mark
    = Arc
    | Area
    | Image
    | Group
    | Line
    | Path
    | Rect
    | Rule
    | Shape
    | Symbol
    | Text
    | Trail


{-| Indicates mark interpolation style.
-}
type MarkInterpolation
    = Basis
    | Cardinal
    | CatmullRom
    | Linear
    | Monotone
    | Natural
    | Stepwise
    | StepAfter
    | StepBefore


{-| Indicates desired orientation of a mark (e.g. horizontally or vertically
oriented bars.)
-}
type MarkOrientation
    = Horizontal
    | Vertical


{-| Indicates an individual property of a mark when encoding. For further details
see the [Vega documentation](https://vega.github.io/vega/docs/marks/#encode).

For details of properties associated with specific mark types, see the Vega documentation
for [arcs](https://vega.github.io/vega/docs/marks/arc/),
[areas](https://vega.github.io/vega/docs/marks/area/),
[groups](https://vega.github.io/vega/docs/marks/group/),
[images](https://vega.github.io/vega/docs/marks/image/),
[lines](https://vega.github.io/vega/docs/marks/line/),
[paths](https://vega.github.io/vega/docs/marks/path/),
[rects](https://vega.github.io/vega/docs/marks/rect/),
[rules](https://vega.github.io/vega/docs/marks/rule/),
[shapes](https://vega.github.io/vega/docs/marks/shape/),
[symbols](https://vega.github.io/vega/docs/marks/symbol/),
[text](https://vega.github.io/vega/docs/marks/text/) and
[trails](https://vega.github.io/vega/docs/marks/trail/).

-}
type MarkProperty
    = MX (List Value)
    | MX2 (List Value)
    | MXC (List Value)
    | MWidth (List Value)
    | MY (List Value)
    | MY2 (List Value)
    | MYC (List Value)
    | MHeight (List Value)
    | MOpacity (List Value)
    | MFill (List Value)
    | MFillOpacity (List Value)
    | MStroke (List Value)
    | MStrokeOpacity (List Value)
    | MStrokeWidth (List Value)
    | MStrokeCap (List Value)
    | MStrokeDash (List Value)
    | MStrokeDashOffset (List Value)
    | MStrokeJoin StrokeJoin
    | MStrokeMiterLimit (List Value)
    | MCursor (List Value)
    | MHRef (List Value)
    | MTooltip (List Value)
    | MZIndex (List Value)
      -- Properties shared by a subset of marks
    | MAlign (List Value)
    | MBaseline (List Value)
    | MCornerRadius (List Value)
    | MInterpolate (List Value)
    | MTension (List Value)
    | MDefined (List Value)
    | MSize (List Value)
      -- Arc mark specific:
    | MStartAngle (List Value)
    | MEndAngle (List Value)
    | MPadAngle (List Value)
    | MInnerRadius (List Value)
    | MOuterRadius (List Value)
      -- Area mark specific:
    | MOrient (List Value)
      -- Group mark specific:
    | MGroupClip (List Value)
      -- Image mark specific:
    | MUrl (List Value)
    | MAspect (List Value)
      -- Path mark specific:
    | MPath (List Value)
      -- Shape mark specific:
    | MShape (List Value)
      -- Symbol mark specific:
    | MSymbol (List Value)
      -- Text mark specific:
    | MAngle (List Value)
    | MDir (List Value)
    | MdX (List Value)
    | MdY (List Value)
    | MEllipsis (List Value)
    | MFont (List Value)
    | MFontSize (List Value)
    | MFontWeight (List Value)
    | MFontStyle (List Value)
    | MLimit (List Value)
    | MRadius (List Value)
    | MText (List Value)
    | MTheta (List Value)


{-| Type of aggregation operation. See the
[Vega documentation](https://vega.github.io/vega/docs/transforms/aggregate/#ops)
for more details.
-}
type Operation
    = ArgMax
    | ArgMin
    | Average
    | CI0
    | CI1
    | Count
    | Distinct
    | Max
    | Mean
    | Median
    | Min
    | Missing
    | Q1
    | Q3
    | Stderr
    | Stdev
    | StdevP
    | Sum
    | Valid
    | Variance
    | VarianceP


{-| Type of overlap strategy to be applied when there is not space to show all
items on an axis. See the
[Vega documentation](https://vega.github.io/vega/docs/axes)
for more details.
-}
type OverlapStrategy
    = ONone
    | OParity
    | OGreedy


{-| Properties of the packing transformation. For details see the
[Vega documentation](https://vega.github.io/vega/docs/transforms/pack)
-}
type PackProperty
    = PaField Field
    | PaSort (List Comparator)
    | PaSize SignalNumber SignalNumber
    | PaRadius (Maybe Field)
    | PaPadding SignalNumber
    | PaAs String String String String String


{-| Properties of the pie chart transformation. For details see the
[Vega documentation](https://vega.github.io/vega/docs/transforms/pie/)
-}
type PieProperty
    = PiField Field
    | PiStartAngle SignalNumber
    | PiEndAngle SignalNumber
    | PiSort SignalBoolean
    | PiAs String String


{-| Indicates whether an ascending or descending order is required (usually in sorting).
-}
type Order
    = Ascend
    | Descend
    | OrderSignal String


{-| Represents padding dimensions in pixel units. `PSize` will set the same value
on all four edges of a rectangular container while `PEdges` can be used to specify
different sizes on each edge in order _left_, _top_, _right_, _bottom_.
-}
type Padding
    = PSize Float
    | PEdges Float Float Float Float


{-| Type of scale range. Can be used to set the default type of range to use
in a scale. The value of the default for each type can be set separately via
config settings. For details see the
[Vega documentation](https://vega.github.io/vega/docs/scales/#range-defaults).
-}
type RangeDefault
    = RWidth
    | RHeight
    | RSymbol
    | RCategory
    | RDiverging
    | ROrdinal
    | RRamp
    | RHeatmap


{-| Used to indicate the type of scale transformation to apply. See the
[Vega documentation](https://vega.github.io/vega/docs/scales/#types) for more details.
-}
type Scale
    = ScLinear
    | ScPow
    | ScSqrt
    | ScLog
    | ScTime
    | ScUtc
    | ScSequential
    | ScOrdinal
    | ScBand
    | ScPoint
    | ScQuantile
    | ScQuantize
    | ScBinLinear
    | ScBinOrdinal
    | ScCustom String


{-| Describes the scale domain (type of data in scale). For full details see the
[Vega documentation](https://vega.github.io/vega/docs/scales/#domain).
-}
type ScaleDomain
    = DNumbers (List Float)
    | DStrings (List String)
      -- TODO: Can we have DateTimes as literals?
      -- TODO: Documentation implies array literals can include signal references as elements. How do we add these?
    | DSignal SignalReference
    | DData (List DataReference)


{-| Describes the way a scale can be rounded to 'nice' numbers. For full details see the
[Vega documentation](https://vega.github.io/vega/docs/scales/#quantitative).
-}
type ScaleNice
    = NMillisecond
    | NSecond
    | NMinute
    | NHour
    | NDay
    | NWeek
    | NMonth
    | NYear
    | NInterval TimeUnit Int
    | NTrue
    | NFalse
    | NTickCount Int


{-| Individual scale property. Scale properties are related, but not identical,
to Vega-Lite's `ScaleProperty` which in Vega are more comprehensive and flexible.
Scale Properties characterise the fundamental data-to-visual transformations applied
by the `scale` function. For more details see the
[Vega documentation](https://vega.github.io/vega/docs/scales/#properties)
-}
type
    ScaleProperty
    -- TODO: Should primitive values (Float, Bool) be replaced with Value so can
    -- respond to signals etc.? See SPaddingInner and SPaddingOuter for examples.
    = SType Scale
    | SDomain ScaleDomain
    | SDomainMax Float
    | SDomainMin Float
    | SDomainMid Float
      -- TODO: Do we need domainRaw? Why not just use SDomain DNumbers [1,2,3] etc.?
    | SRange ScaleRange
    | SReverse Bool
    | SRound Bool
    | SClamp Bool
    | SInterpolate CInterpolate
    | SPadding Float
    | SNice ScaleNice
    | SZero Bool
    | SExponent Float
    | SBase Float
    | SAlign Float
    | SPaddingInner Value
    | SPaddingOuter Value
    | SRangeStep Float


{-| Describes a scale range of scale output values. For full details see the
[Vega documentation](https://vega.github.io/vega/docs/scales/#range).
-}
type ScaleRange
    = RNumbers (List Float)
    | RStrings (List String)
    | RValues (List Value)
    | RSignal SignalReference
    | RScheme String (List SchemeProperty)
    | RData DataReference
    | RStep Value
    | RDefault RangeDefault


{-| Describes a color scheme. For details see the
[Vega documentation](https://vega.github.io/vega/docs/schemes/).
-}
type SchemeProperty
    = SScheme String
    | SCount Float
    | SExtent Float Float


{-| Indicates a rectangular side. Can be used to specify an axis position.
[Vega documentation](https://vega.github.io/vega/docs/axes/#orientation)
for more details.
-}
type Side
    = SLeft
    | SRight
    | STop
    | SBottom


{-| Represents a boolean value that can either be a literal `SigBool` or signal that
references a boolean value.
-}
type SignalBoolean
    = SigBool Bool
    | SigBoolRef SignalReference


{-| Represents a numeric value that can either be a literal `SigNum` or signal that
references a number.
-}
type SignalNumber
    = SigNum Float
    | SigNumRef SignalReference


{-| Represents a string value that can either be a literal `SigStr` or signal that
references a string.
-}
type SignalString
    = SigStr String
    | SigStrRef SignalReference


{-| Represents a signal name or expression. For details see the
[Vega documentation](https://vega.github.io/vega/docs/types/#Signal).
-}
type SignalReference
    = SName String
    | SExpr Expression


{-| Individual signal property. For details see the
[Vega documentation](https://vega.github.io/vega/docs/signals).
-}
type SignalProperty
    = SiName String
    | SiBind Bind
    | SiDescription String
    | SiOn (List (List EventHandler))
    | SiUpdate Expression
    | SiReact Bool
    | SiValue DataValue
    | SiValues DataValues


{-| Allow type of sorting to be customised. For details see the
[Vega documentation](https://vega.github.io/vega/docs/scales/#sort).
-}
type SortProperty
    = Ascending
    | Descending
    | Op Operation
    | ByField String


{-| Indicates the data source for a set of marks. For details see the
[Vega documentation](https://vega.github.io/vega/docs/marks/#from).
-}
type Source
    = SData String
    | SFacet (List Facet)


{-| Represents a Vega specification. Specs can be (and usually are) nested.
They can range from a single Boolean value up to the entire Vega specification.
-}
type alias Spec =
    JE.Value


{-| Indicates the type of offsetting to apply when stacking. `OfZero` uses a baseline
at the foot of a stack, `OfCenter` uses a central baseline with stacking both above
and below it, while `OfNormalize` rescales stack to a common height while preserving
the relative size of stacked quantities. For details see the
[Vega documentation](https://vega.github.io/vega/docs/transforms/stack)
-}
type StackOffset
    = OfZero
    | OfCenter
    | OfNormalize
    | OffsetSignal String


{-| Properties of the stacking transformation. For details see the
[Vega documentation](https://vega.github.io/vega/docs/transforms/stack/)
-}
type StackProperty
    = StField Field
    | StGroupBy (List Field)
    | StSort (List Comparator)
    | StOffset StackOffset
    | StAs String String


{-| Type of stroke cap.
-}
type StrokeCap
    = CButt
    | CRound
    | CSquare


{-| Type of stroke join.
-}
type StrokeJoin
    = JMiter
    | JRound
    | JBevel


{-| Identifies the type of symbol. The `Path` symbol is used to define custom shapes
as an SVG path description.
-}
type Symbol
    = SymCircle
    | SymSquare
    | Cross
    | Diamond
    | TriangleUp
    | TriangleDown
    | SymPath String


{-| Direction text is rendered. This determines which end of a text string is
truncated if it cannot be displated within a restricted space.
-}
type TextDirection
    = LeftToRight
    | RightToLeft


{-| Describes a unit of time. Useful for encoding and transformations. See the
[Vega documentation](https://vega.github.io/vega/docs/scales/#quantitative)
for further details.
-}
type
    -- TODO: Vega-Lite seems to have more time unit options than Vega (e.g. Quarter, Hours etc. - Check spec to see if this is a doc problem or a genuinely restricted set in Vega)
    TimeUnit
    = Year
    | YearQuarter
    | YearQuarterMonth
    | YearMonth
    | YearMonthDate
    | YearMonthDateHours
    | YearMonthDateHoursMinutes
    | YearMonthDateHoursMinutesSeconds
    | Quarter
    | QuarterMonth
    | Month
    | MonthDate
    | Date
    | Day
    | Hours
    | HoursMinutes
    | HoursMinutesSeconds
    | Minutes
    | MinutesSeconds
    | Seconds
    | SecondsMilliseconds
    | Milliseconds
    | Utc TimeUnit


{-| Indicates the charactersitcs of a mark. For further
details see the [Vega documentation](https://vega.github.io/vega/docs/marks).

Whole specifications can nested within the `Group` mark (including further nested
group specifications) by specifying `MType Group` and suppyling the specification
as a series of properties supplied to `MGroup`. For example,

    TODO: XXX MGroup example

-}
type TopMarkProperty
    = MType Mark
    | MClip Bool
    | MDescription String
    | MEncode (List EncodingProperty)
    | MFrom (List Source)
    | MInteractive Bool
    | MKey String
    | MName String
    | MOn (List Trigger)
    | MSort (List Comparator)
      -- TODO: MTransform (List Transform) combining with Data transform functions
    | MRole String
    | MStyle (List String)
    | MGroup (List ( VProperty, Spec ))


{-| Defines a transformation that may be applied to a data stream or mark.
For details see the [Vega documentation](https://vega.github.io/vega/docs/transforms).
-}
type
    Transform
    -- TODO: Parameterise remaining transforms
    = TAggregate (List AggregateProperty)
    | TBin
    | TCollect
    | TCountPattern
    | TCross
    | TDensity
    | TExtent Field
    | TExtentAsSignal Field String
    | TFilter Expr
    | TFold
    | TFormula Expression String FormulaUpdate
    | TIdentifier
    | TImpute
    | TJoinAggregate
    | TLookup
    | TProject
    | TSample
    | TSequence
    | TWindow
    | TContour
    | TGeoJson
    | TGeoPath
    | TGeoPoint
    | TGeoShape
    | TGraticule
    | TLinkpath
    | TPie (List PieProperty)
    | TStack (List StackProperty)
    | TForce
    | TVoronoi
    | TWordCloud
    | TNest
    | TStratify Field Field
    | TTreeLinks
    | TPack (List PackProperty)
    | TPartition
    | TTree
    | TTreeMap
    | TCrossFilter
    | TResolveFilter


{-| Represents a trigger enabling dynamic updates to data and marks. For details
see the [Vega documentation](https://vega.github.io/vega/docs/triggers/)
-}
type alias Trigger =
    Spec


{-| Defines a trigger that can cause a data stream or mark to update.
For details see the [Vega documentation](https://vega.github.io/vega/docs/triggers).
-}
type TriggerProperty
    = TrTrigger Expression
    | TrInsert Expression
      -- TODO: Do we need the boolean option here or is an expression `true` sufficient?
    | TrRemove Expression
    | TrToggle Expression
    | TrModifyValues Expression Expression


{-| Indicates the vertical alignment of some text or an image mark. Note that the
`Alphabetic` type constructor applies only to text marks.
-}
type VAlign
    = AlignTop
    | AlignMiddle
    | AlignBottom
    | Alphabetic


{-| Represents a value such as a number or reference to a value such as a field label
or transformed value. For details, see the
[Vega documentation](https://vega.github.io/vega/docs/types/#Value)
-}
type Value
    = VSignal SignalReference
    | VColor ColorValue
    | VField FieldValue
    | VScale FieldValue
    | VBand Float
    | VExponent Value
    | VMultiply Value
    | VOffset Value
    | VRound Bool
    | VNumber Float
    | VNumbers (List Float)
    | VObject (List Value)
    | VString String
    | VBool Bool
    | VNull
    | VIfElse String (List Value) (List Value)


{-| Top-level Vega properties. These are for testing purposes only prior to full
Vega spec generatation being made available.
-}
type VProperty
    = VName
    | VDescription
    | VBackground
    | VTitle
    | VWidth
    | VAutosize
    | VHeight
    | VPadding
    | VAutoSize
    | VConfig
    | VSignals
    | VData
    | VScales
    | VProjections
    | VAxes
    | VLegends
    | VMarks


{-| Declare the way the view is sized. See the
[Vega documentation](https://vega.github.io/vega/docs/specification/#autosize-types)
for details.

    TODO: XXX

-}
autosize : List Autosize -> ( VProperty, Spec )
autosize aus =
    ( VAutosize, JE.object (List.map autosizeProperty aus) )


{-| Create the axes used to visualize spatial scale mappings.

    TODO: XXX

-}
axes : List Spec -> ( VProperty, Spec )
axes axs =
    ( VAxes, JE.list axs )


{-| Create a single axis used to visualize a spatial scale mapping.

    TODO: XXX

-}
axis : String -> Side -> List AxisProperty -> List Spec -> List Spec
axis scName side aps =
    (::) (JE.object (AxScale scName :: AxSide side :: aps |> List.map axisProperty))


{-| Combines a list of labelled specifications into a single specification that
may be passed to JavaScript for rendering. This is useful when you wish to create
a single page with multiple visulizualizations.

    combineSpecs
        [ ( "vis1", myFirstVis )
        , ( "vis2", mySecondVis )
        , ( "vis3", myOtherVis )
        ]

-}
combineSpecs : List LabelledSpec -> Spec
combineSpecs specs =
    JE.object specs


{-| A convenience function for generating a text string representing a given cursor
type. This can be used instead of specifying an cursor type as a literal string
to avoid problems of mistyping its name.

    TODO: XXX Provide example

-}
cursorLabel : Cursor -> String
cursorLabel cur =
    case cur of
        CAuto ->
            "auto"

        CDefault ->
            "default"

        CNone ->
            "none"

        CContextMenu ->
            "context-menu"

        CHelp ->
            "help"

        CPointer ->
            "pointer"

        CProgress ->
            "progress"

        CWait ->
            "wait"

        CCell ->
            "cell"

        CCrosshair ->
            "crosshair"

        CText ->
            "text"

        CVerticalText ->
            "vertical-text"

        CAlias ->
            "alias"

        CCopy ->
            "copy"

        CMove ->
            "move"

        CNoDrop ->
            "no-drop"

        CNotAllowed ->
            "not-allowed"

        CAllScroll ->
            "all-scroll"

        CColResize ->
            "col-resize"

        CRowResize ->
            "row-resize"

        CNResize ->
            "n-resize"

        CEResize ->
            "e-resize"

        CSResize ->
            "s-resize"

        CWResize ->
            "w-resize"

        CNEResize ->
            "ne-resize"

        CNWResize ->
            "nw-resize"

        CSEResize ->
            "se-resize"

        CSWResize ->
            "sw-resize"

        CEWResize ->
            "ew-resize"

        CNSResize ->
            "ns-resize"

        CNESWResize ->
            "nesw-resize"

        CNWSEResize ->
            "nwse-resize"

        CZoomIn ->
            "zoom-in"

        CZoomOut ->
            "zoom-out"

        CGrab ->
            "grab"

        CGrabbing ->
            "grabbing"


{-| Create a column of data. A column has a name and a list of values. The final
parameter is the list of any other columns to which this is added.

    dataColumn "Animal" (Strings [ "Cat", "Dog", "Mouse"]) []

-}
dataColumn : String -> DataValues -> List DataColumn -> List DataColumn
dataColumn colName data =
    case data of
        Numbers col ->
            (::) (List.map (\x -> ( colName, JE.float x )) col)

        Strings col ->
            (::) (List.map (\s -> ( colName, JE.string s )) col)

        DateTimes col ->
            (::) (List.map (\s -> ( colName, JE.string s )) col)

        Booleans col ->
            (::) (List.map (\b -> ( colName, JE.bool b )) col)

        DataValues col ->
            (::) (List.map (\dv -> ( colName, dataValues dv )) col)


{-| Declare a data table from a provided list of column values. Each column contains
values of the same type, but columns each with a different type are permitted.
Columns should all contain the same number of items; if not the dataset will be
truncated to the length of the shortest column. The first parameter should be the
name given to the data table for later reference. An optional list for field
formatting instructions can be provided in the second parameter or an empty list
to use the default formatting. See the
[Vega documentation](https://vega.github.io/vega/docs/data/#format)
for details.
The columns themselves are most easily generated with `dataColumn`

    dataTable =
        dataFromColumns "animals" [ Parse [ ( "Year", FDate "%Y" ) ] ]
            << dataColumn "Animal" (Strings [ "Fish", "Dog", "Cat" ])
            << dataColumn "Age" (Numbers [ 28, 12, 6 ])
            << dataColumn "Year" (Strings [ "2010", "2014", "2015" ])

-}
dataFromColumns : String -> List Format -> List DataColumn -> DataTable
dataFromColumns name fmts cols =
    let
        dataArray =
            cols
                |> transpose
                |> List.map JE.object
                |> JE.list

        fmt =
            if fmts == [] then
                []
            else
                [ ( "format", JE.object (List.concatMap formatProperty fmts) ) ]
    in
    [ ( "name", JE.string name ), ( "values", dataArray ) ] ++ fmt


{-| Declare a data source from a provided list of row values. Each row contains
a list of tuples where the first value is a string representing the column name, and the
second the column value for that row. Each column can have a value of a different type
but you must ensure that when subsequent rows are added, they match the types of previous
values with shared column names. An optional list for field formatting instructions can
be provided in the first parameter or an empty list to use the default formatting. See the
[Vega-Lite documentation](https://vega.github.io/vega-lite/docs/data.html#format)
for details.
The rows themselves are most easily generated with `dataRow`. Note though that generally
if you are creating data inline (as opposed to reading from a file), adding data by column
in more efficent and less error-prone.

    dataTable =
        dataFromRows "animals" [ Parse [ ( "Year", FDate "%Y" ) ] ]
            << dataRow [ ( "Animal", Str "Fish" ), ( "Age", Number 28 ), ( "Year", Str "2010" ) ]
            << dataRow [ ( "Animal", Str "Dog" ), ( "Age", Number 12 ), ( "Year", Str "2014" ) ]
            << dataRow [ ( "Animal", Str "Cat" ), ( "Age", Number 6 ), ( "Year", Str "2015" ) ]

-}
dataFromRows : String -> List Format -> List DataRow -> DataTable
dataFromRows name fmts rows =
    let
        fmt =
            if fmts == [] then
                []
            else
                [ ( "format", JE.object (List.concatMap formatProperty fmts) ) ]
    in
    [ ( "name", JE.string name ), ( "values", JE.list rows ) ] ++ fmt


{-| Declare a named data set. Depending on the properties provided this may be
from an external file, from a named data source or inline literal values. See the
[Vega documentation](https://vega.github.io/vega/docs/data/#propertiess) for details.

      dataSource
          [ data "pop" [ DUrl "data/population.json" ]
          , data "popYear" [ DSource "pop" ] |> transform [ TFilter (Expr "datum.year == year") ]
          ]

-}
data : String -> List DataProperty -> DataTable
data name dProps =
    ( "name", JE.string name ) :: List.map dataProperty dProps


{-| Create a row of data. A row comprises a list of (columnName,value) pairs.
The final parameter is the list of any other rows to which this is added.

    dataRow [("Animal", Str "Fish"),("Age",Number 28),("Year", Str "2010")] []

-}
dataRow : List ( String, DataValue ) -> List DataRow -> List DataRow
dataRow row =
    (::) (JE.object (List.map (\( colName, val ) -> ( colName, dataValue val )) row))


{-| Specify a data source to be used in the visualization. A data source is a collection
of data tables which themselves may be generated inline, loaded from a URL or the
result of a transformation. For details see the
[Vega documentation](https://vega.github.io/vega/docs/data).

      dataSource
          [ data "pop" [ DUrl "data/population.json" ]
          , data "popYear" [ DSource "pop" ] |> transform [ TFilter (Expr "datum.year == year") ]
          , data "males" [ DSource "popYear" ] |> transform [ TFilter (Expr "datum.sex == 1") ]
          , data "females" [ DSource "popYear" ] |> transform [ TFilter (Expr "datum.sex == 2") ]
          , data "ageGroups" [ DSource "pop" ] |> transform [ TAggregate [ AgGroupBy [ FieldName "age" ] ] ]
          ]

-}
dataSource : List DataTable -> ( VProperty, Spec )
dataSource dataTables =
    ( VData, JE.list (List.map JE.object dataTables) )


{-| A convenience function for generating a text string representing a given text
direction type. This can be used instead of specifying an direction type as a
literal string to avoid problems of mistyping its name.

    TODO: XXX Provide example

-}
dirLabel : TextDirection -> String
dirLabel dir =
    case dir of
        LeftToRight ->
            "ltr"

        RightToLeft ->
            "rtl"


{-| A convenience function for generating a text string representing a horizontal
alignment type. This can be used instead of specifying an alignment type as a
literal string to avoid problems of mistyping its name.

      MEncode [ Enter [ MAlign [hAlignLabel AlignCenter |> VString ] ] ]

-}
hAlignLabel : HAlign -> String
hAlignLabel align =
    case align of
        AlignLeft ->
            "left"

        AlignCenter ->
            "center"

        AlignRight ->
            "right"


{-| Override the default width of the visualization. If not specified the width
will be calculated based on the content of the visualization.

    TODO: XXX

-}
height : Float -> ( VProperty, Spec )
height w =
    ( VHeight, JE.float w )


{-| Create a single legend used to visualize a colour, size or shape mapping.

    TODO: XXX

-}
legend : List LegendProperty -> List Spec -> List Spec
legend lps =
    (::) (JE.object (List.map legendProperty lps))


{-| Create legends used to visualize color, size and shape mappings.

    TODO: XXX

-}
legends : List Spec -> ( VProperty, Spec )
legends lgs =
    ( VLegends, JE.list lgs )


{-| Create a single mark definition.

    TODO: XXX

-}
mark : Mark -> List TopMarkProperty -> List Spec -> List Spec
mark mark mps =
    (::) (JE.object (MType mark :: mps |> List.concatMap topMarkProperty))


{-| Create the marks used in the visualization.

    TODO: XXX

-}
marks : List Spec -> ( VProperty, Spec )
marks axs =
    ( VMarks, JE.list axs )


{-| A convenience function for generating a text string representing a given mark
interpolation type. This can be used instead of specifying an interpolation type
as a literal string to avoid problems of mistyping the interpolation name.

    signals
       << signal "interp" [ SiValue (markInterpolationLabel Linear |> Str) ]

-}
markInterpolationLabel : MarkInterpolation -> String
markInterpolationLabel interp =
    case interp of
        Basis ->
            "basis"

        Cardinal ->
            "cardinal"

        CatmullRom ->
            "catmull-rom"

        Linear ->
            "linear"

        Monotone ->
            "monotone"

        Natural ->
            "natural"

        Stepwise ->
            "step"

        StepAfter ->
            "step-after"

        StepBefore ->
            "step-before"


{-| A convenience function for generating a text string representing a given mark
orientation type. This can be used instead of specifying an orientation type as
a literal string to avoid problems of mistyping its name.

    TODO: XXX Add example

-}
markOrientationLabel : MarkOrientation -> String
markOrientationLabel orient =
    case orient of
        Horizontal ->
            "horizontal"

        Vertical ->
            "vertical"


{-| Adds list of triggers to the given data table or mark.
For details see the [Vega documentation](https://vega.github.io/vega/docs/triggers).
-}
on : List Spec -> DataTable -> DataTable
on triggerSpecs dTable =
    dTable ++ [ ( "on", JE.list triggerSpecs ) ]


{-| Set the padding around the visualization in pixel units. The way padding is
interpreted will depend on the `autosize` properties. See the
[Vega documentation](https://vega.github.io/vega/docs/specification/)
for details.

    TODO: XXX

-}
padding : Padding -> ( VProperty, Spec )
padding pad =
    ( VPadding, paddingSpec pad )


{-| Create a single scale used to map data values to visual properties.

    TODO: XXX

-}
scale : String -> List ScaleProperty -> List Spec -> List Spec
scale name sps =
    (::) (JE.object (( "name", JE.string name ) :: List.map scaleProperty sps))


{-| Create the scales used to map data values to visual properties.

    TODO: XXX

-}
scales : List Spec -> ( VProperty, Spec )
scales scs =
    ( VScales, JE.list scs )


{-| Create the signals used to add dynamism to the visualization.
For further details see the [Vega documentation](https://vega.github.io/vega/docs/signals)

    TODO: XXX

-}
signals : List Spec -> ( VProperty, Spec )
signals sigs =
    ( VSignals, JE.list sigs )


{-| Create a single signal used to add a dynamic component to a visualization.
For further details see the [Vega documentation](https://vega.github.io/vega/docs/signals)

    TODO: XXX

-}
signal : String -> List SignalProperty -> List Spec -> List Spec
signal sigName sps =
    (::) (JE.object (SiName sigName :: sps |> List.map signalProperty))


{-| Preset signal representing the current height of the visualization.
-}
sigHeight : SignalNumber
sigHeight =
    SigNumRef (SName "height")


{-| Preset signal representing the current padding setting of the visualization.
-}
sigPadding : SignalNumber
sigPadding =
    SigNumRef (SName "padding")


{-| Preset signal representing the current width of the visualization.
-}
sigWidth : SignalNumber
sigWidth =
    SigNumRef (SName "width")


{-| A convenience function for generating a text string representing a given
stroke cap type. This can be used instead of specifying an stroke cap type
as a literal string to avoid problems of mistyping its name.

    signal "strokeCap" [ SiValue (strokeCapLabel CRound |> Str)]

-}
strokeCapLabel : StrokeCap -> String
strokeCapLabel cap =
    case cap of
        CButt ->
            "butt"

        CRound ->
            "round"

        CSquare ->
            "square"


{-| A convenience function for generating a text string representing a given
stroke join type. This can be used instead of specifying an stroke join type
as a literal string to avoid problems of mistyping its name.

TODO: XXX Example

-}
strokeJoinLabel : StrokeJoin -> String
strokeJoinLabel join =
    case join of
        JMiter ->
            "miter"

        JRound ->
            "round"

        JBevel ->
            "bevel"


{-| A convenience function for generating a text string representing a given
symbol type. This can be used instead of specifying an symbol type as a literal
string to avoid problems of mistyping its name.

    TODO: XXX Example

-}
symbolLabel : Symbol -> String
symbolLabel sym =
    case sym of
        SymCircle ->
            "circle"

        SymSquare ->
            "square"

        Cross ->
            "cross"

        Diamond ->
            "diamond"

        TriangleUp ->
            "triangle-up"

        TriangleDown ->
            "triangle-down"

        SymPath svgPath ->
            svgPath


{-| Convert a list of Vega specifications into a single JSON object that may be
passed to Vega for graphics generation.
Currently this is a placeholder only and is not available for use.
-}
toVega : List ( VProperty, Spec ) -> Spec
toVega spec =
    ( "$schema", JE.string "https://vega.github.io/schema/vega/v3.0.json" )
        :: List.map (\( s, v ) -> ( vPropertyLabel s, v )) spec
        |> JE.object


{-| Applies the given ordered list of transforms to the given data table.
For details see the [Vega documentation](https://vega.github.io/vega/docs/transforms).

      dataSource
          [ data "pop" [ DUrl "data/population.json" ]
          , data "popYear" [ DSource "pop" ] |> transform [ TFilter (Expr "datum.year == year") ]
          , data "ageGroups" [ DSource "pop" ] |> transform [ TAggregate [ AgGroupBy [ FieldName "age" ] ] ]
          ]

-}
transform : List Transform -> DataTable -> DataTable
transform transforms dTable =
    dTable ++ [ ( "transform", JE.list (List.map transformSpec transforms) ) ]


{-| Creates a trigger that may be applied to a data table or mark.
The first parameter is the name of the trigger and the second
a list of trigger actions.
-}
trigger : String -> List TriggerProperty -> Trigger
trigger trName trProps =
    JE.object (List.concatMap triggerProperties (TrTrigger trName :: trProps))


{-| A convenience function for generating a text string representing a vertical
alignment type. This can be used instead of specifying an alignment type as a
literal string to avoid problems of mistyping its name.

      MEncode [ Enter [MBaseline [ vAlignLabel AlignBottom |> VString ] ] ]

-}
vAlignLabel : VAlign -> String
vAlignLabel align =
    case align of
        AlignTop ->
            "top"

        AlignMiddle ->
            "middle"

        AlignBottom ->
            "bottom"

        Alphabetic ->
            "alphabetic"


{-| Override the default width of the visualization. If not specified the width
will be calculated based on the content of the visualization.

    TODO: XXX

-}
width : Float -> ( VProperty, Spec )
width w =
    ( VWidth, JE.float w )



-- ################################################# Private types and functions


type alias LabelledSpec =
    ( String, Spec )


aggregateProperty : AggregateProperty -> LabelledSpec
aggregateProperty ap =
    case ap of
        AgGroupBy fs ->
            ( "groupby", JE.list (List.map fieldSpec fs) )

        AgFields fs ->
            ( "fields", JE.list (List.map fieldSpec fs) )

        AgOps ops ->
            ( "ops", JE.list (List.map (\op -> opSpec op) ops) )

        AgAs labels ->
            ( "as", JE.list (List.map JE.string labels) )

        AgCross b ->
            ( "cross", JE.bool b )

        AgDrop b ->
            ( "drop", JE.bool b )


autosizeProperty : Autosize -> LabelledSpec
autosizeProperty asCfg =
    case asCfg of
        APad ->
            ( "type", JE.string "pad" )

        AFit ->
            ( "type", JE.string "fit" )

        ANone ->
            ( "type", JE.string "none" )

        AResize ->
            ( "resize", JE.bool True )

        AContent ->
            ( "contains", JE.string "content" )

        APadding ->
            ( "contains", JE.string "padding" )


axisElementLabel : AxisElement -> String
axisElementLabel el =
    case el of
        EAxis ->
            "axis"

        ETicks ->
            "ticks"

        EGrid ->
            "grid"

        ELabels ->
            "labels"

        ETitle ->
            "title"

        EDomain ->
            "domain"


axisProperty : AxisProperty -> LabelledSpec
axisProperty ap =
    case ap of
        AxScale scName ->
            ( "scale", JE.string scName )

        AxSide axSide ->
            ( "orient", JE.string (sideLabel axSide) )

        AxFormat fmt ->
            ( "format", JE.string fmt )

        AxDomain b ->
            ( "domain", JE.bool b )

        AxEncode elEncs ->
            let
                enc ( el, encProps ) =
                    ( axisElementLabel el, JE.object (List.map encodingProperty encProps) )
            in
            ( "encode", JE.object (List.map enc elEncs) )

        AxGrid b ->
            ( "grid", JE.bool b )

        AxLabels b ->
            ( "labels", JE.bool b )

        AxLabelOverlap strat ->
            ( "labelOverlap", JE.string (overlapStrategyLabel strat) )

        AxLabelPadding pad ->
            ( "labelPadding", JE.float pad )

        AxMaxExtent val ->
            ( "maxExtent", valueSpec val )

        AxMinExtent val ->
            ( "minExtent", valueSpec val )

        AxGridScale scName ->
            ( "gridScale", JE.string scName )

        AxLabelBound numOrNothing ->
            case numOrNothing of
                Nothing ->
                    ( "labelBound", JE.bool False )

                Just x ->
                    ( "labelBound", JE.float x )

        AxLabelFlush numOrNothing ->
            case numOrNothing of
                Nothing ->
                    ( "labelFlush", JE.bool False )

                Just x ->
                    ( "labelFlush", JE.float x )

        AxLabelFlushOffset pad ->
            ( "labelFlushOffset", JE.float pad )

        AxOffset val ->
            ( "offset", valueSpec val )

        AxPosition val ->
            ( "position", valueSpec val )

        AxTicks b ->
            ( "ticks", JE.bool b )

        AxTickCount n ->
            ( "tickCount", JE.int n )

        AxTickSize sz ->
            ( "tickSize", JE.float sz )

        AxTitle val ->
            ( "title", valueSpec val )

        AxTitlePadding pad ->
            ( "titlePadding", JE.float pad )

        AxValues vals ->
            ( "values", JE.list (List.map valueSpec vals) )

        AxZIndex n ->
            ( "zindex", JE.int n )


bindingProperty : Bind -> LabelledSpec
bindingProperty bnd =
    let
        bSpec iType props =
            ( "bind", JE.object (( "input", JE.string iType ) :: List.map inputProperty props) )
    in
    case bnd of
        IRange props ->
            bSpec "range" props

        ICheckbox props ->
            bSpec "checkbox" props

        IRadio props ->
            bSpec "radio" props

        ISelect props ->
            bSpec "select" props

        IText props ->
            bSpec "text" props

        INumber props ->
            bSpec "number" props

        IDate props ->
            bSpec "date" props

        ITime props ->
            bSpec "time" props

        IMonth props ->
            bSpec "month" props

        IWeek props ->
            bSpec "week" props

        IDateTimeLocal props ->
            bSpec "datetimelocal" props

        ITel props ->
            bSpec "tel" props

        IColor props ->
            bSpec "color" props


colorProperty : ColorValue -> LabelledSpec
colorProperty cVal =
    case cVal of
        RGB r g b ->
            ( "color", JE.object [ ( "r", JE.float r ), ( "g", JE.float g ), ( "b", JE.float b ) ] )

        HSL h s l ->
            ( "color", JE.object [ ( "h", JE.float h ), ( "s", JE.float s ), ( "l", JE.float l ) ] )

        LAB l a b ->
            ( "color", JE.object [ ( "l", JE.float l ), ( "a", JE.float a ), ( "b", JE.float b ) ] )

        HCL h c l ->
            ( "color", JE.object [ ( "h", JE.float h ), ( "c", JE.float c ), ( "l", JE.float l ) ] )


comparatorProperty : Comparator -> LabelledSpec
comparatorProperty comp =
    case comp of
        CoField fs ->
            ( "field", JE.list (List.map fieldSpec fs) )

        CoOrder os ->
            ( "order", JE.list (List.map orderSpec os) )


dataProperty : DataProperty -> LabelledSpec
dataProperty dProp =
    case dProp of
        DFormat fmt ->
            ( "format", JE.object (formatProperty fmt) )

        DSource src ->
            ( "source", JE.string src )

        DSources srcs ->
            ( "source", JE.list (List.map JE.string srcs) )

        DOn triggers ->
            ( "on", JE.list triggers )

        DUrl url ->
            ( "url", JE.string url )

        DValue val ->
            ( "values", valueSpec val )


dataRefProperty : DataReference -> LabelledSpec
dataRefProperty dataRef =
    case dataRef of
        DDataset ds ->
            ( "data", JE.string ds )

        DField val ->
            ( "field", valueSpec val )

        DFields vals ->
            ( "fields", JE.list (List.map valueSpec vals) )

        DReferences drs ->
            ( "fields", JE.object (List.map dataRefProperty drs) )

        DSort sps ->
            if sps == [ Ascending ] then
                ( "sort", JE.bool True )
            else
                ( "sort", JE.object (List.map sortProperty sps) )


dataValue : DataValue -> Spec
dataValue val =
    case val of
        Number x ->
            JE.float x

        Str s ->
            JE.string s

        Boolean b ->
            JE.bool b

        Empty ->
            JE.object []

        Null ->
            JE.null


dataValues : DataValues -> Spec
dataValues vals =
    case vals of
        Booleans bs ->
            JE.list (List.map JE.bool bs)

        DateTimes dts ->
            JE.list (List.map JE.string dts)

        Strings ss ->
            JE.list (List.map JE.string ss)

        Numbers xs ->
            JE.list (List.map JE.float xs)

        DataValues dvs ->
            JE.list (List.map dataValues dvs)


encodingProperty : EncodingProperty -> LabelledSpec
encodingProperty ep =
    case ep of
        Enter mProps ->
            ( "enter", JE.object (List.map markProperty mProps) )

        Update mProps ->
            ( "update", JE.object (List.map markProperty mProps) )

        Exit mProps ->
            ( "exit", JE.object (List.map markProperty mProps) )

        Hover mProps ->
            ( "hover", JE.object (List.map markProperty mProps) )

        Custom s mProps ->
            ( s, JE.object (List.map markProperty mProps) )


eventHandlerSpec : List EventHandler -> Spec
eventHandlerSpec ehs =
    let
        eventHandler eh =
            case eh of
                EEvents s ->
                    ( "events", JE.string s )

                EUpdate s ->
                    if s == "" then
                        ( "update", JE.string "{}" )
                    else
                        ( "update", JE.string s )

                EEncode s ->
                    ( "encode", JE.string s )

                EForce b ->
                    ( "force", JE.bool b )
    in
    JE.object (List.map eventHandler ehs)


exprProperty : Expr -> LabelledSpec
exprProperty expr =
    case expr of
        EField field ->
            ( "field", JE.string field )

        Expr expr ->
            ( "expr", expressionSpec expr )


expressionSpec : Expression -> Spec
expressionSpec expr =
    -- TODO: Would be better to parse expressions for correctness
    JE.string expr


facetProperty : Facet -> LabelledSpec
facetProperty fct =
    case fct of
        FaName s ->
            ( "name", JE.string s )

        FaData s ->
            ( "data", JE.string s )

        FaField s ->
            ( "field", JE.string s )

        FaGroupBy ss ->
            ( "groupby", JE.list (List.map JE.string ss) )


fieldSpec : Field -> Spec
fieldSpec f =
    case f of
        FieldName s ->
            JE.string s

        FieldSignal sigName ->
            signalStrSpec (SigStrRef (SName sigName))



--signalStrSpec


fieldValueSpec : FieldValue -> Spec
fieldValueSpec fVal =
    case fVal of
        FName fName ->
            JE.string fName

        FSignal sig ->
            JE.object [ signalReferenceProperty sig ]

        FDatum fv ->
            JE.object [ ( "datum", fieldValueSpec fv ) ]

        FGroup fv ->
            JE.object [ ( "group", fieldValueSpec fv ) ]

        FParent fv ->
            JE.object [ ( "parent", fieldValueSpec fv ) ]


foDataTypeSpec : DataType -> Spec
foDataTypeSpec dType =
    case dType of
        FoNumber ->
            JE.string "number"

        FoBoolean ->
            JE.string "boolean"

        FoDate dateFmt ->
            if dateFmt == "" then
                JE.string "date"
            else
                JE.string ("date:'" ++ dateFmt ++ "'")

        FoUtc dateFmt ->
            if dateFmt == "" then
                JE.string "utc"
            else
                JE.string ("utc:'" ++ dateFmt ++ "'")


formatProperty : Format -> List LabelledSpec
formatProperty fmt =
    case fmt of
        JSON ->
            [ ( "type", JE.string "json" ) ]

        CSV ->
            [ ( "type", JE.string "csv" ) ]

        TSV ->
            [ ( "type", JE.string "tsv" ) ]

        DSV delim ->
            [ ( "type", JE.string "dsv" ), ( "delimeter", JE.string delim ) ]

        TopojsonFeature objectSet ->
            [ ( "type", JE.string "json" ), ( "feature", JE.string objectSet ) ]

        TopojsonMesh objectSet ->
            [ ( "type", JE.string "json" ), ( "mesh", JE.string objectSet ) ]

        Parse fmts ->
            [ ( "parse", JE.object <| List.map (\( field, fmt ) -> ( field, foDataTypeSpec fmt )) fmts ) ]


formulaUpdateSpec : FormulaUpdate -> Spec
formulaUpdateSpec update =
    case update of
        InitOnly ->
            JE.bool True

        AlwaysUpdate ->
            JE.bool False


interpolateSpec : CInterpolate -> Spec
interpolateSpec iType =
    case iType of
        Rgb gamma ->
            JE.object [ ( "type", JE.string "rgb" ), ( "gamma", JE.float gamma ) ]

        Hsl ->
            JE.object [ ( "type", JE.string "hsl" ) ]

        HslLong ->
            JE.object [ ( "type", JE.string "hsl-long" ) ]

        Lab ->
            JE.object [ ( "type", JE.string "lab" ) ]

        Hcl ->
            JE.object [ ( "type", JE.string "hcl" ) ]

        HclLong ->
            JE.object [ ( "type", JE.string "hcl-long" ) ]

        CubeHelix gamma ->
            JE.object [ ( "type", JE.string "cubehelix" ), ( "gamma", JE.float gamma ) ]

        CubeHelixLong gamma ->
            JE.object [ ( "type", JE.string "cubehelix-long" ), ( "gamma", JE.float gamma ) ]


inputProperty : InputProperty -> LabelledSpec
inputProperty prop =
    case prop of
        InMin x ->
            ( "min", JE.float x )

        InMax x ->
            ( "max", JE.float x )

        InStep x ->
            ( "step", JE.float x )

        Debounce x ->
            ( "debounce", JE.float x )

        InName s ->
            ( "name", JE.string s )

        InOptions opts ->
            ( "options", dataValues opts )

        InPlaceholder el ->
            ( "placeholder", JE.string el )

        Element el ->
            ( "element", JE.string el )

        -- Autocomplete appears to be undocumented in https://vega.github.io/vega/docs/signals/
        -- but is used in this example: https://vega.github.io/vega/examples/job-voyager/
        -- TODO: Any other HTML 5 attributes missing?
        InAutocomplete b ->
            if b then
                ( "autocomplete", JE.string "on" )
            else
                ( "autocomplete", JE.string "off" )


legendEncodingProperty : LegendEncoding -> LabelledSpec
legendEncodingProperty le =
    case le of
        EnLegend eps ->
            ( "legend", JE.object (List.map encodingProperty eps) )

        EnTitle eps ->
            ( "title", JE.object (List.map encodingProperty eps) )

        EnLabels eps ->
            ( "labels", JE.object (List.map encodingProperty eps) )

        EnSymbols eps ->
            ( "symbols", JE.object (List.map encodingProperty eps) )

        EnGradient eps ->
            ( "gradient", JE.object (List.map encodingProperty eps) )


legendProperty : LegendProperty -> LabelledSpec
legendProperty lp =
    case lp of
        LeType lt ->
            ( "type", JE.string (legendTypeLabel lt) )

        LOrient lo ->
            ( "orient", JE.string (legendOrientLabel lo) )

        LFill fScale ->
            ( "fill", JE.string fScale )

        LOpacity oScale ->
            ( "opacity", JE.string oScale )

        LShape sScale ->
            ( "shape", JE.string sScale )

        LSize sScale ->
            ( "size", JE.string sScale )

        LStroke sScale ->
            ( "stroke", JE.string sScale )

        LStrokeDash sdScale ->
            ( "strokeDash", JE.string sdScale )

        LEncode les ->
            ( "encode", JE.object (List.map legendEncodingProperty les) )

        LEntryPadding val ->
            ( "entryPadding", valueSpec val )

        LFormat f ->
            ( "format", JE.string f )

        LOffset val ->
            ( "offset", valueSpec val )

        LPadding val ->
            ( "padding", valueSpec val )

        LTickCount n ->
            ( "tickCount", JE.int n )

        LTitlePadding val ->
            ( "titlePadding", valueSpec val )

        LTitle t ->
            ( "title", JE.string t )

        LValues vals ->
            ( "values", JE.list (List.map valueSpec vals) )

        LZIndex n ->
            ( "zindex", JE.int n )


legendOrientLabel : LegendOrientation -> String
legendOrientLabel orient =
    case orient of
        Left ->
            "left"

        TopLeft ->
            "top-left"

        Top ->
            "top"

        TopRight ->
            "top-right"

        Right ->
            "right"

        BottomRight ->
            "bottom-right"

        Bottom ->
            "bottom"

        BottomLeft ->
            "bottom-left"

        None ->
            "none"


legendTypeLabel : LegendType -> String
legendTypeLabel lt =
    case lt of
        LSymbol ->
            "symbol"

        LGradient ->
            "gradient"


markLabel : Mark -> String
markLabel m =
    case m of
        Arc ->
            "arc"

        Area ->
            "area"

        Image ->
            "image"

        Group ->
            "group"

        Line ->
            "line"

        Path ->
            "path"

        Rect ->
            "rect"

        Rule ->
            "rule"

        Shape ->
            "shape"

        Symbol ->
            "symbol"

        Text ->
            "text"

        Trail ->
            "trail"


markProperty : MarkProperty -> LabelledSpec
markProperty mProp =
    case mProp of
        MX vals ->
            ( "x", valRef vals )

        MY vals ->
            ( "y", valRef vals )

        MX2 vals ->
            ( "x2", valRef vals )

        MY2 vals ->
            ( "y2", valRef vals )

        MXC vals ->
            ( "xc", valRef vals )

        MYC vals ->
            ( "xc", valRef vals )

        MWidth vals ->
            ( "width", valRef vals )

        MHeight vals ->
            ( "height", valRef vals )

        MOpacity vals ->
            ( "opacity", valRef vals )

        MFill vals ->
            ( "fill", valRef vals )

        MFillOpacity vals ->
            ( "fillOpacity", valRef vals )

        MStroke vals ->
            ( "stroke", valRef vals )

        MStrokeOpacity vals ->
            ( "strokeOpacity", valRef vals )

        MStrokeWidth vals ->
            ( "strokeWidth", valRef vals )

        MStrokeCap vals ->
            ( "strokeCap", valRef vals )

        MStrokeDash vals ->
            ( "strokeDash", valRef vals )

        MStrokeDashOffset vals ->
            ( "strokeDashOffset", valRef vals )

        MStrokeJoin join ->
            ( "strokeJoin", JE.string (strokeJoinLabel join) )

        MStrokeMiterLimit vals ->
            ( "strokeMiterLimit", valRef vals )

        MCursor vals ->
            ( "cursor", valRef vals )

        MHRef vals ->
            ( "href", valRef vals )

        MTooltip vals ->
            ( "tooltip", valRef vals )

        MZIndex vals ->
            ( "zindex", valRef vals )

        -- Arc Mark specific:
        MStartAngle vals ->
            ( "startAngle", valRef vals )

        MEndAngle vals ->
            ( "endAngle", valRef vals )

        MPadAngle vals ->
            ( "padAngle", valRef vals )

        MInnerRadius vals ->
            ( "innerRadius", valRef vals )

        MOuterRadius vals ->
            ( "outerRadius", valRef vals )

        MCornerRadius vals ->
            ( "cornerRadius", valRef vals )

        -- Area Mark specific:
        MOrient vals ->
            ( "orient", valRef vals )

        MInterpolate vals ->
            ( "interpolate", valRef vals )

        MTension vals ->
            ( "tension", valRef vals )

        MDefined vals ->
            ( "defined", valRef vals )

        -- Group Mark specific (MCornerRadius shared with other marks):
        MGroupClip vals ->
            ( "clip", valRef vals )

        -- Image Mark specific:
        MAspect vals ->
            ( "aspect", valRef vals )

        MUrl vals ->
            ( "url", valRef vals )

        -- Path Mark specific:
        MPath vals ->
            ( "path", valRef vals )

        -- Shape Mark specific:
        MShape vals ->
            ( "shape", valRef vals )

        -- Symbol Mark specific:
        MSize vals ->
            ( "size", valRef vals )

        MSymbol vals ->
            ( "shape", valRef vals )

        -- Text Mark specific (MAlign shared with other marks):
        MAlign vals ->
            ( "align", valRef vals )

        MAngle vals ->
            ( "angle", valRef vals )

        MBaseline vals ->
            ( "baseline", valRef vals )

        MDir vals ->
            ( "dir", valRef vals )

        MdX vals ->
            ( "dx", valRef vals )

        MdY vals ->
            ( "dy", valRef vals )

        MEllipsis vals ->
            ( "ellipsis", valRef vals )

        MFont vals ->
            ( "font", valRef vals )

        MFontSize vals ->
            ( "fontSize", valRef vals )

        MFontWeight vals ->
            ( "fontWeight", valRef vals )

        MFontStyle vals ->
            ( "fontStyle", valRef vals )

        MLimit vals ->
            ( "limit", valRef vals )

        MRadius vals ->
            ( "radius", valRef vals )

        MText vals ->
            ( "text", valRef vals )

        MTheta vals ->
            ( "theta", valRef vals )


niceSpec : ScaleNice -> Spec
niceSpec ni =
    case ni of
        NMillisecond ->
            JE.string "millisecond"

        NSecond ->
            JE.string "second"

        NMinute ->
            JE.string "minute"

        NHour ->
            JE.string "hour"

        NDay ->
            JE.string "day"

        NWeek ->
            JE.string "week"

        NMonth ->
            JE.string "month"

        NYear ->
            JE.string "year"

        NInterval tu step ->
            JE.object [ ( "interval", JE.string (timeUnitLabel tu) ), ( "step", JE.int step ) ]

        NTrue ->
            JE.bool True

        NFalse ->
            JE.bool False

        NTickCount n ->
            JE.int n


opSpec : Operation -> Spec
opSpec op =
    case op of
        ArgMax ->
            JE.string "argmax"

        ArgMin ->
            JE.string "argmin"

        Average ->
            JE.string "average"

        Count ->
            JE.string "count"

        CI0 ->
            JE.string "ci0"

        CI1 ->
            JE.string "ci1"

        Distinct ->
            JE.string "distinct"

        Max ->
            JE.string "max"

        Mean ->
            JE.string "mean"

        Median ->
            JE.string "median"

        Min ->
            JE.string "min"

        Missing ->
            JE.string "missing"

        Q1 ->
            JE.string "q1"

        Q3 ->
            JE.string "q3"

        Stdev ->
            JE.string "stdev"

        StdevP ->
            JE.string "stdevp"

        Sum ->
            JE.string "sum"

        Stderr ->
            JE.string "stderr"

        Valid ->
            JE.string "valid"

        Variance ->
            JE.string "variance"

        VarianceP ->
            JE.string "variancep"


orderSpec : Order -> Spec
orderSpec order =
    case order of
        Ascend ->
            JE.string "ascending"

        Descend ->
            JE.string "descending"

        OrderSignal sigName ->
            signalStrSpec (SigStrRef (SName sigName))


overlapStrategyLabel : OverlapStrategy -> String
overlapStrategyLabel strat =
    case strat of
        ONone ->
            "false"

        OParity ->
            "parity"

        OGreedy ->
            "greedy"


packProperty : PackProperty -> LabelledSpec
packProperty pp =
    case pp of
        PaField f ->
            ( "field", fieldSpec f )

        PaSort comp ->
            ( "sort", JE.object (List.map comparatorProperty comp) )

        PaSize w h ->
            ( "size", JE.list [ signalNumSpec w, signalNumSpec h ] )

        PaRadius fOrNull ->
            case fOrNull of
                Just f ->
                    ( "radius", fieldSpec f )

                Nothing ->
                    ( "radius", JE.null )

        PaPadding padSize ->
            ( "padding", signalNumSpec padSize )

        PaAs x y r depth children ->
            ( "as", JE.list (List.map JE.string [ x, y, r, depth, children ]) )


paddingSpec : Padding -> Spec
paddingSpec pad =
    case pad of
        PSize p ->
            JE.float p

        PEdges l t r b ->
            JE.object
                [ ( "left", JE.float l )
                , ( "top", JE.float t )
                , ( "right", JE.float r )
                , ( "bottom", JE.float b )
                ]


pieProperty : PieProperty -> LabelledSpec
pieProperty pp =
    case pp of
        PiField f ->
            ( "field", fieldSpec f )

        PiStartAngle x ->
            ( "startAngle", signalNumSpec x )

        PiEndAngle x ->
            ( "endAngle", signalNumSpec x )

        PiSort b ->
            ( "sort", signalBoolSpec b )

        PiAs y0 y1 ->
            ( "as", JE.list (List.map JE.string [ y0, y1 ]) )


rangeDefaultLabel : RangeDefault -> String
rangeDefaultLabel rd =
    case rd of
        RWidth ->
            "width"

        RHeight ->
            "height"

        RSymbol ->
            "symbol"

        RCategory ->
            "category"

        RDiverging ->
            "diverging"

        ROrdinal ->
            "ordinal"

        RRamp ->
            "ramp"

        RHeatmap ->
            "heatmap"


scaleDomainSpec : ScaleDomain -> Spec
scaleDomainSpec sdType =
    case sdType of
        DNumbers nums ->
            JE.list (List.map JE.float nums)

        DStrings cats ->
            JE.list (List.map JE.string cats)

        DSignal signal ->
            JE.object [ signalReferenceProperty signal ]

        DData dataRef ->
            JE.object (List.map dataRefProperty dataRef)


scaleLabel : Scale -> String
scaleLabel scType =
    case scType of
        ScLinear ->
            "linear"

        ScPow ->
            "pow"

        ScSqrt ->
            "sqrt"

        ScLog ->
            "log"

        ScTime ->
            "time"

        ScUtc ->
            "utc"

        ScSequential ->
            "sequential"

        ScOrdinal ->
            "ordinal"

        ScBand ->
            "band"

        ScPoint ->
            "point"

        ScBinLinear ->
            "bin-linear"

        ScBinOrdinal ->
            "bin-ordinal"

        ScQuantile ->
            "quantile"

        ScQuantize ->
            "quantize"

        ScCustom s ->
            s


scaleProperty : ScaleProperty -> LabelledSpec
scaleProperty scaleProp =
    case scaleProp of
        SType sType ->
            ( "type", JE.string (scaleLabel sType) )

        SDomain sdType ->
            ( "domain", scaleDomainSpec sdType )

        SDomainMax sdMax ->
            ( "domainMax", JE.float sdMax )

        SDomainMin sdMin ->
            ( "domainMin", JE.float sdMin )

        SDomainMid sdMid ->
            ( "domainMid", JE.float sdMid )

        SRange range ->
            case range of
                RNumbers xs ->
                    ( "range", JE.list (List.map JE.float xs) )

                RStrings ss ->
                    ( "range", JE.list (List.map JE.string ss) )

                RValues vals ->
                    ( "range", JE.list (List.map valueSpec vals) )

                RSignal sig ->
                    ( "range", JE.object [ signalReferenceProperty sig ] )

                RScheme name options ->
                    ( "range", JE.object (List.map schemeProperty (SScheme name :: options)) )

                RData dRef ->
                    ( "range", JE.object [ dataRefProperty dRef ] )

                RStep val ->
                    ( "range", JE.object [ ( "step", valueSpec val ) ] )

                RDefault rd ->
                    ( "range", JE.string (rangeDefaultLabel rd) )

        SPadding x ->
            ( "padding", JE.float x )

        SPaddingInner val ->
            ( "paddingInner", valueSpec val )

        SPaddingOuter val ->
            ( "paddingOuter", valueSpec val )

        SRangeStep x ->
            ( "rangeStep", JE.float x )

        SRound b ->
            ( "round", JE.bool b )

        SClamp b ->
            ( "clamp", JE.bool b )

        SInterpolate interp ->
            ( "interpolate", interpolateSpec interp )

        SNice ni ->
            ( "nice", niceSpec ni )

        SZero b ->
            ( "zero", JE.bool b )

        SReverse b ->
            ( "reverse", JE.bool b )

        SExponent x ->
            ( "exponent", JE.float x )

        SBase x ->
            ( "base", JE.float x )

        SAlign x ->
            ( "align", JE.float x )


schemeProperty : SchemeProperty -> LabelledSpec
schemeProperty sProps =
    case sProps of
        SScheme sName ->
            ( "scheme", JE.string sName )

        SCount x ->
            ( "count", JE.float x )

        SExtent mn mx ->
            ( "extent", JE.list [ JE.float mn, JE.float mx ] )


sideLabel : Side -> String
sideLabel orient =
    case orient of
        SLeft ->
            "left"

        SBottom ->
            "bottom"

        SRight ->
            "right"

        STop ->
            "top"


signalBoolSpec : SignalBoolean -> Spec
signalBoolSpec sigBool =
    case sigBool of
        SigBool b ->
            JE.bool b

        SigBoolRef sig ->
            JE.object [ signalReferenceProperty sig ]


signalNumSpec : SignalNumber -> Spec
signalNumSpec sigNum =
    case sigNum of
        SigNum x ->
            JE.float x

        SigNumRef sig ->
            JE.object [ signalReferenceProperty sig ]


signalStrSpec : SignalString -> Spec
signalStrSpec sigStr =
    case sigStr of
        SigStr s ->
            JE.string s

        SigStrRef sig ->
            JE.object [ signalReferenceProperty sig ]


signalProperty : SignalProperty -> LabelledSpec
signalProperty sigProp =
    case sigProp of
        SiName siName ->
            ( "name", JE.string siName )

        SiBind bind ->
            bindingProperty bind

        SiDescription s ->
            ( "description", JE.string s )

        SiUpdate expr ->
            ( "update", expressionSpec expr )

        SiOn ehs ->
            ( "on", JE.list (List.map eventHandlerSpec ehs) )

        SiReact b ->
            ( "react", JE.bool b )

        SiValue v ->
            ( "value", dataValue v )

        SiValues vs ->
            ( "value", dataValues vs )


signalReferenceProperty : SignalReference -> LabelledSpec
signalReferenceProperty signal =
    case signal of
        SName sName ->
            ( "signal", JE.string sName )

        SExpr sExpr ->
            ( "signal", expressionSpec sExpr )


sortProperty : SortProperty -> LabelledSpec
sortProperty sp =
    case sp of
        Ascending ->
            ( "order", JE.string "ascending" )

        Descending ->
            ( "order", JE.string "descending" )

        ByField field ->
            ( "field", JE.string field )

        Op op ->
            ( "op", opSpec op )


sourceProperty : Source -> LabelledSpec
sourceProperty src =
    case src of
        SData sName ->
            ( "data", JE.string sName )

        SFacet fcts ->
            ( "facet", JE.object (List.map facetProperty fcts) )


stackOffsetSpec : StackOffset -> Spec
stackOffsetSpec off =
    case off of
        OfZero ->
            JE.string "zero"

        OfCenter ->
            JE.string "center"

        OfNormalize ->
            JE.string "normalize"

        OffsetSignal sigName ->
            signalStrSpec (SigStrRef (SName sigName))


stackProperty : StackProperty -> LabelledSpec
stackProperty sp =
    case sp of
        StField f ->
            ( "field", fieldSpec f )

        StGroupBy fs ->
            ( "groupby", JE.list (List.map fieldSpec fs) )

        StSort comp ->
            ( "sort", JE.object (List.map comparatorProperty comp) )

        StOffset off ->
            ( "offset", stackOffsetSpec off )

        StAs y0 y1 ->
            ( "as", JE.list (List.map JE.string [ y0, y1 ]) )


timeUnitLabel : TimeUnit -> String
timeUnitLabel tu =
    case tu of
        Year ->
            "year"

        YearQuarter ->
            "yearquarter"

        YearQuarterMonth ->
            "yearquartermonth"

        YearMonth ->
            "yearmonth"

        YearMonthDate ->
            "yearmonthdate"

        YearMonthDateHours ->
            "yearmonthdatehours"

        YearMonthDateHoursMinutes ->
            "yearmonthdatehoursminutes"

        YearMonthDateHoursMinutesSeconds ->
            "yearmonthdatehoursminutesseconds"

        Quarter ->
            "quarter"

        QuarterMonth ->
            "quartermonth"

        Month ->
            "month"

        MonthDate ->
            "monthdate"

        Date ->
            "date"

        Day ->
            "day"

        Hours ->
            "hours"

        HoursMinutes ->
            "hoursminutes"

        HoursMinutesSeconds ->
            "hoursminutesseconds"

        Minutes ->
            "minutes"

        MinutesSeconds ->
            "minutesseconds"

        Seconds ->
            "seconds"

        SecondsMilliseconds ->
            "secondsmilliseconds"

        Milliseconds ->
            "milliseconds"

        Utc timeUnit ->
            "utc" ++ timeUnitLabel timeUnit


topMarkProperty : TopMarkProperty -> List LabelledSpec
topMarkProperty mProp =
    case mProp of
        MType m ->
            [ ( "type", JE.string (markLabel m) ) ]

        MClip b ->
            [ ( "clip", JE.bool b ) ]

        MDescription s ->
            [ ( "description", JE.string s ) ]

        MEncode eps ->
            [ ( "encode", JE.object (List.map encodingProperty eps) ) ]

        MFrom src ->
            [ ( "from", JE.object (List.map sourceProperty src) ) ]

        MInteractive b ->
            [ ( "interactive", JE.bool b ) ]

        MKey s ->
            [ ( "key", JE.string s ) ]

        MName s ->
            [ ( "name", JE.string s ) ]

        MOn triggers ->
            [ ( "on", JE.list triggers ) ]

        -- TODO: MTransform Transform []
        MRole s ->
            [ ( "role", JE.string s ) ]

        MSort comp ->
            [ ( "sort", JE.object (List.map comparatorProperty comp) ) ]

        MStyle ss ->
            [ ( "style", JE.list (List.map JE.string ss) ) ]

        MGroup props ->
            List.map (\( vProp, spec ) -> ( vPropertyLabel vProp, spec )) props


transformSpec : Transform -> Spec
transformSpec trans =
    case trans of
        TAggregate aps ->
            JE.object (( "type", JE.string "aggregate" ) :: List.map aggregateProperty aps)

        TBin ->
            JE.object [ ( "type", JE.string "bin" ) ]

        TCollect ->
            JE.object [ ( "type", JE.string "collect" ) ]

        TCountPattern ->
            JE.object [ ( "type", JE.string "countpattern" ) ]

        TCross ->
            JE.object [ ( "type", JE.string "cross" ) ]

        TDensity ->
            JE.object [ ( "type", JE.string "density" ) ]

        TExtent field ->
            JE.object [ ( "type", JE.string "extent" ), ( "field", fieldSpec field ) ]

        TExtentAsSignal field sigName ->
            JE.object [ ( "type", JE.string "extent" ), ( "field", fieldSpec field ), ( "signal", JE.string sigName ) ]

        TFilter expr ->
            JE.object [ ( "type", JE.string "filter" ), exprProperty expr ]

        TFold ->
            JE.object [ ( "type", JE.string "fold" ) ]

        TFormula expr name update ->
            JE.object
                [ ( "type", JE.string "formula" )
                , ( "expr", expressionSpec expr )
                , ( "as", JE.string name )
                , ( "initonly", formulaUpdateSpec update )
                ]

        TIdentifier ->
            JE.object [ ( "type", JE.string "identifier" ) ]

        TImpute ->
            JE.object [ ( "type", JE.string "impute" ) ]

        TJoinAggregate ->
            JE.object [ ( "type", JE.string "joinaggregate" ) ]

        TLookup ->
            JE.object [ ( "type", JE.string "lookup" ) ]

        TProject ->
            JE.object [ ( "type", JE.string "project" ) ]

        TSample ->
            JE.object [ ( "type", JE.string "sample" ) ]

        TSequence ->
            JE.object [ ( "type", JE.string "sequence" ) ]

        TWindow ->
            JE.object [ ( "type", JE.string "window" ) ]

        TContour ->
            JE.object [ ( "type", JE.string "contour" ) ]

        TGeoJson ->
            JE.object [ ( "type", JE.string "geojson" ) ]

        TGeoPath ->
            JE.object [ ( "type", JE.string "geopath" ) ]

        TGeoPoint ->
            JE.object [ ( "type", JE.string "geopoint" ) ]

        TGeoShape ->
            JE.object [ ( "type", JE.string "geoshape" ) ]

        TGraticule ->
            JE.object [ ( "type", JE.string "graticule" ) ]

        TLinkpath ->
            JE.object [ ( "type", JE.string "linkpath" ) ]

        TPie pps ->
            JE.object (( "type", JE.string "pie" ) :: List.map pieProperty pps)

        TStack sps ->
            JE.object (( "type", JE.string "stack" ) :: List.map stackProperty sps)

        TForce ->
            JE.object [ ( "type", JE.string "force" ) ]

        TVoronoi ->
            JE.object [ ( "type", JE.string "voronoi" ) ]

        TWordCloud ->
            JE.object [ ( "type", JE.string "wordcloud" ) ]

        TNest ->
            JE.object [ ( "type", JE.string "nest" ) ]

        TStratify key parent ->
            JE.object [ ( "type", JE.string "stratify" ), ( "key", fieldSpec key ), ( "parentKey", fieldSpec parent ) ]

        TTreeLinks ->
            JE.object [ ( "type", JE.string "treelinks" ) ]

        TPack pps ->
            JE.object (( "type", JE.string "pack" ) :: List.map packProperty pps)

        TPartition ->
            JE.object [ ( "type", JE.string "partition" ) ]

        TTree ->
            JE.object [ ( "type", JE.string "tree" ) ]

        TTreeMap ->
            JE.object [ ( "type", JE.string "treemap" ) ]

        TCrossFilter ->
            JE.object [ ( "type", JE.string "crossfilter" ) ]

        TResolveFilter ->
            JE.object [ ( "type", JE.string "resolvefilter" ) ]


transpose : List (List a) -> List (List a)
transpose ll =
    case ll of
        [] ->
            []

        [] :: xss ->
            transpose xss

        (x :: xs) :: xss ->
            let
                heads =
                    List.filterMap List.head xss

                tails =
                    List.filterMap List.tail xss
            in
            (x :: heads) :: transpose (xs :: tails)


triggerProperties : TriggerProperty -> List LabelledSpec
triggerProperties trans =
    case trans of
        TrTrigger expr ->
            [ ( "trigger", expressionSpec expr ) ]

        TrInsert expr ->
            [ ( "insert", expressionSpec expr ) ]

        TrRemove expr ->
            [ ( "remove", expressionSpec expr ) ]

        TrToggle expr ->
            [ ( "toggle", expressionSpec expr ) ]

        -- Note the one-to-many relation between this trigger property and the labelled specs it generates.
        TrModifyValues modExpr valExpr ->
            [ ( "modify", expressionSpec modExpr ), ( "values", expressionSpec valExpr ) ]


valRef : List Value -> Spec
valRef vs =
    case vs of
        [ VIfElse expr ifs elses ] ->
            JE.list
                [ JE.object (( "test", JE.string expr ) :: List.map valueProperty ifs)
                , JE.object (List.map valueProperty elses)
                ]

        _ ->
            JE.object (List.map valueProperty vs)


valueProperty : Value -> LabelledSpec
valueProperty val =
    let
        evaluate val =
            case val of
                VNumber x ->
                    JE.float x

                _ ->
                    valueSpec val
    in
    case val of
        VSignal sig ->
            signalReferenceProperty sig

        VColor cVal ->
            colorProperty cVal

        VField fVal ->
            ( "field", fieldValueSpec fVal )

        VScale fVal ->
            ( "scale", fieldValueSpec fVal )

        VBand x ->
            ( "band", JE.float x )

        VExponent val ->
            ( "exponent", evaluate val )

        VMultiply val ->
            ( "mult", evaluate val )

        VOffset val ->
            ( "offset", evaluate val )

        VRound b ->
            ( "round", JE.bool b )

        VNumber num ->
            ( "value", JE.float num )

        VNumbers nums ->
            ( "value", JE.list (List.map JE.float nums) )

        VObject vals ->
            ( "value", JE.object (List.map valueProperty vals) )

        VString str ->
            ( "value", JE.string str )

        VBool b ->
            ( "value", JE.bool b )

        VNull ->
            ( "value", JE.null )

        VIfElse expr ifs elses ->
            ( "productionRule"
            , JE.object
                [ ( "test", JE.string expr )
                , ( "if", JE.object (List.map valueProperty ifs) )
                , ( "else", JE.object (List.map valueProperty elses) )
                ]
            )
                |> Debug.log "Unexpected production rule passed to valueProperty"


valueSpec : Value -> Spec
valueSpec val =
    case val of
        VSignal sig ->
            JE.object [ signalReferenceProperty sig ]

        VColor cVal ->
            JE.object [ colorProperty cVal ]

        VField fName ->
            fieldValueSpec fName

        VScale fName ->
            fieldValueSpec fName

        VBand x ->
            JE.object [ ( "band", JE.float x ) ]

        VExponent val ->
            JE.object [ valueProperty val ]

        VMultiply val ->
            JE.object [ valueProperty val ]

        VOffset val ->
            JE.object [ valueProperty val ]

        VRound b ->
            JE.object [ ( "round", JE.bool b ) ]

        VNumber num ->
            JE.float num

        VNumbers nums ->
            JE.list (List.map JE.float nums)

        VObject objs ->
            JE.object (List.map valueProperty objs)

        VString str ->
            JE.string str

        VBool b ->
            JE.bool b

        VNull ->
            JE.null

        VIfElse expr ifs elses ->
            JE.null


vPropertyLabel : VProperty -> String
vPropertyLabel spec =
    case spec of
        VName ->
            "name"

        VDescription ->
            "description"

        VBackground ->
            "background"

        VTitle ->
            "title"

        VWidth ->
            "width"

        VAutosize ->
            "autosize"

        VHeight ->
            "height"

        VPadding ->
            "padding"

        VAutoSize ->
            "autosize"

        VConfig ->
            "config"

        VSignals ->
            "signals"

        VData ->
            "data"

        VScales ->
            "scales"

        VProjections ->
            "projections"

        VAxes ->
            "axes"

        VLegends ->
            "legends"

        VMarks ->
            "marks"
